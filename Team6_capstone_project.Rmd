#Team 6: Paula, Sadiksha**
  
# üß¨ Capstone Project: R-based Mass Spectrometry Proteomics Workflow
  
#This document provides a step-by-step guide for your capstone project on analyzing proteomics data using R.

---
  
## üîÅ Workflow Overview
  ### 1. üìÅ Dataset Acquisition  
  #**Input:** PRIDE PXD Identifier  
 
#(*Example: `PXD0123456`, accessible via [PRIDE](https://www.ebi.ac.uk/pride/)*)

#Use the `rpx` package to access metadata and download a dataset that includes `.mzID` files from a published study.
```{r}
library(rpx)
px <- PXDataset("PXD054877")  # Create a PXDataset object for the dataset with ID "PXD056514" #female
pxfiles(px) ## Retrieve and display a list of all files associated with the PXDataset object 'px'
```


---
  
### 2. üß± PSM Object Creation & Preprocessing  
#**Goal:** Generate a PSM (Peptide-Spectrum Match) object from `.mzID` files  
 
#- Convert `.mzID` files into `PSM` objects
# Assess:
# Number of decoy hits
# Score distributions
# PSM rank
# Apply filtering based on FDR or identification score

```{r}
library(PSMatch)
library(ggplot2)
```

# Step 1: Access the dataset
```{r}
files <- pxfiles(px) #Retrieve and display a list of all files associated with the PXDataset object 'px'
mzid_files <- pxget(px, grep("mzid", pxfiles(px))) #Identify the .mzID files from the retrieved files
```
```{r}
psms <- PSM(mzid_files, parser = 'mzID')
```
```{r}
names(psms)
```

```{r}
#Score distributions
# Score distributions
score_distribution <- summary(id$`Mascot:score`)
score_distribution <- summary(psms@listData$`mascot:score`)
print(score_distribution)
#hist(psms@listData$`mascot:score`, breaks = 100) #one way to do histogram
psm_df <- as.data.frame(psms) #Converted into dataframe because it is just easier to check in environment and easier to work on for me. Please ignore this if you don't want to do dataframe and read the columns in similar way as line 58 hist script :) but the dataframe is for exploring and visualization only. we will do filtering in actual object psms in later steps
table(psm_df$passthreshold) #true#57251 may be after removing decoys or delta score or mascot score thereshold? 

library(ggplot2)
ggplot(psm_df, aes(x = mascot.score)) +
  geom_density()+
   labs(title = "Density Plot of Mascot Scores",
       x = "Mascot Score",
       y = "Density") +
  theme_minimal() 
```
```{r}
#when filtering one plan is to remove everything at 0. just exploring where to filter
ggplot(psm_df, aes(x = mascot.score)) +
  geom_density(fill = "blue", alpha = 0.5) +  # Fill color for the density plot
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +  # Vertical line at x = 1
  labs(title = "Density Plot of Mascot Scores",
       x = "Mascot Score",
       y = "Density") +
  theme_minimal() 
```


```{r}
#decoy
#no isdecoy column
#one way is to check if there are proteins without description?
sum(is.na(psm_df$description)) #0
```

```{r}
# PSM rank
psm_rank_distribution <- table(psm_df$rank)
print(psm_rank_distribution) #we dont have many that have higher rank
```

```{r}
#Apply filtering based on FDR or identification score (keeping mascot score >1)?
#not using dataframe bit 

```

```{r}
adjacencyMatrix(psms)
```




#Apply filtering based on FDR or identification score
threshold <- 0.01  # Set your FDR or score threshold
#I dont see fdr in this data, also which score?

#i dont know which score to use
library(ggplot2)
ggplot(id, aes(x =  `Mascot:score`,
               colour = isDecoy)) +
  geom_density()

---
  
### 3. üß¨ Protein & Peptide Identification  
# **Goal:** Determine identified peptides and proteins  
#Count the number of identified peptides and proteins
#Review peptide-to-protein mapping:
#Razor proteins
#Protein groups

identified_peptides <- unique(id$peptide)  # Get unique peptides
length(identified_peptides)
#23785
identified_proteins <- unique(id$accession)  # Get unique protein accessions 
length(identified_proteins)
#8055

# Create a mapping of peptides to proteins
peptide_to_protein_mapping <- table(id$peptide, id$accession)

library(dplyr)
razor_proteins <- id %>%
  group_by(peptide) %>%  # Group by peptide
  filter(!is.na(accession)) %>%  # Filter out NA accessions
  slice(which.max(`Mascot:score`)) %>%  # Select the highest-scoring protein
  ungroup() %>%  # Ungroup to return to the original data frame structure
  select(peptide, Leading.razor.protein = accession)  # Select relevant columns
#For all 23785 peptides
table(razor_proteins$Leading.razor.protein)
length(unique(razor_proteins$Leading.razor.protein)) #7716 proteins. There are so many. may be there can't be so many razor proteins. are these protein groups then?

#Protein groups (based on unique accessions)
proteins <- unique(id$accession)  # Extract unique protein accessions

---
  
### 4. üîÑ QFeature Aggregation (Optional)  
# **Goal:** Use quantification data if available  
  
#Use `aggregateFeatures()` from the `QFeatures` package to aggregate:
  #PSMs ‚û°Ô∏è Peptides ‚û°Ô∏è Proteins

library(QFeatures)
library(dplyr)  
qfeatures <- QFeatures(list(PSM = SummarizedExperiment(assays = list(lognorm_peptides = as.matrix(id)))))
# Assuming 'peptide' is the column with peptide sequences and 'Mascot:score' is the scoring metric

rowData(qfeatures[["PSM"]])
qfeatures[["PSM"]]
data("b1370p17_S9_Tot_Prot_P31_FRAX_24h_1000nM_3.RAW.-1.mgf")

qfeatures <- aggregateFeatures(qfeatures,
                               i = "PSM",  # Input assay
                               name = "Peptides",  # Name of the new aggregated feature
                               fcol = "peptide",  # Column containing peptide sequences
                               fun = colMeans,  # Aggregation function (mean of scores, for example)
                               na.rm = TRUE)

library(MSnbase)



---
  
  ### 5. üßº Normalization & Imputation (Optional)  
  **Goal:** Correct for technical variation and handle missing values  
‚Üì  
- Normalize using `normalize()` or `normalize_vsn()`
- Impute missing values with `impute()`

---
  
  ### 6. üß™ Protein Inference & Quantification (Optional)  
  **Goal:** Summarize and quantify proteins  
‚Üì  
- Aggregate peptide-level intensities into protein-level quantities
- Optionally annotate protein IDs using external databases (e.g., UniProt)

---
  
  ### 7. üìä Statistical Analysis (Optional)  
  **Goal:** Identify differentially abundant proteins  
‚Üì  
- Perform statistical testing (e.g., using `test_diff()`)
- Filter by:
  - Log2 fold-change
- Adjusted p-value (e.g., FDR < 0.05)

---
  
  ### 8. üìà Visualization & Export (Optional)  
  **Goal:** Visualize data for interpretation  
‚Üì  
- Create visual summaries:
  - PCA plots
- Volcano plots
- Heatmaps  
- Use packages such as `ggplot2`, `DEP`, or `limma`

---
  
  ### 9. üìñ Comparison with Published Results  
  **Goal:** Benchmark your findings  
‚Üì  
Create a comparison table including:
  - Number of spectra identified
- Number of peptides and proteins
- Key figures or results (if available)
- Comments on reproducibility

---
  
  ### 10. üìù Final Report & Interpretation  
  **Goal:** Reflect on your analysis  
‚Üì  
Submit the following:
  - Source code (R script or RMarkdown) in your team folder
- A 1‚Äì2 page report that includes:
  - Background of the dataset and study
- Summary table of key results
- Discussion:
  > Why do your results match or differ from the original publication?
  
  ---
  
  ‚úÖ **Tip:** Convert your `.Rmd` into a clean `README.md` using `knitr::knit("README.Rmd")`.
